## 环境
### 虚拟环境
#### 搭建虚拟环境
安装虚拟环境
```python

pip install virtualenv
```
新建一个文件夹，作为虚拟环境，通过cd命令进入，执行
```python
virtualenv .
```
该命令可以把当前文件夹作为虚拟文件
#### 启用虚拟环境
进入虚拟环境文件夹，可以看到一个Scripts文件夹，进入，运行activate
```txt
E:\>cd testvir\Scripts

E:\testvir\Scripts>activate
```
成功启用后会看见路径前面加了一个括号，里面是虚拟环境文件夹名
```python
(testvir) E:\testvir\Scripts
```
### 项目
#### 创建项目
在虚拟环境文件夹中新建一个文件用来存放所有Django项目  
进入该项目文件夹，运行
```python
django-admin startproject  (项目名称)
```
#### 启动服务器
进入创建的项目文件夹，会有manage.py的一个文件，运行
```python
python manage.py runserver
```
运行成功会有如下提示
>Performing system checks...
System check identified no issues (0 silenced).
You have 15 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
Run 'python manage.py migrate' to apply them.
January 20, 2019 - 09:47:57
Django version 2.1.4, using settings 'ToDouList.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CTRL-BREAK.

访问 http://127.0.0.1:8000/ 可以看到Django欢迎界面
#### 各文件作用
##### urls
该文件用来处理url 原理是对匹配的url 进行切割，切割后的url传递给app中urls处理，如
```python
urlpatterns = [
    path('admin/', admin.site.urls),
    path('todo/',include(todolist.urls))
]
```
在浏览器中输入 `http://127.0.0.1:8000/todo/home/1/` 其中`http://127.0.0.1:8000/`是服务器，会被直接分掉，在`http://127.0.0.1:8000/ `之后的`/todo/home/1/`与`urlpatterns`匹配，就会把`todo/`之后的东西分发给`todolist.urls`处理
##### settings
该文件是创建项目时自动生成的，用来设置项目相关的数据库，app等信息
## Django APP
在Django中，每个App负责一个功能
### App注册
#### 新建App
在项目文件夹下面运行
```python
python manage.py startapp (app名称)
```
#### 注册app
新建app后，需要注册，才能使Django识别
打开 <font color=#9ACD32 >项目文件夹</font>下面的setting.py文件中的
```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
```
这就是目前项目中所有用到的app,这些都是官方提供的，我们按照格式填上自己新建的app，在最后写上app名即可
```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'todolist',
]
```
### App中重要文件作用
#### urls
该文件夹需要自己创建，用来处理从项目文件夹中分发过来的url，原理与项目文件夹相同
#### views
用来实现app视图相关的大部分后端逻辑
#### static
django推荐的静态文件文件夹，需要自己创建，用来储存css,js,图片等静态文件，为了避免静态文件重名，一般在static中再建一个与app同名的文件夹，静态文件分类放在该文件夹中
#### templates
django推荐的存放html页面的文件夹，同样为了避免重名，在内部可以建一个与app同名的文件夹

### 模板继承
诸如导航栏之类的，每个页面都有的东西，不必要复制很多，可以新建一个html 文件，django推荐命名是base.html,作为父模板，每个页面需要这些元素时，只需要继承该模板即可，具体方法是：  

* base.html
```txt
# 这些是父模板，诸如导航栏之类

{% block 导航栏 %}
{% endblock 导航栏 %}
```
**注意：** `导航栏`是block标签名
* 子页
```python
{% extends "todolist/base.html"%}
{% block 导航栏 %}
{% endblock 主题 %}
```
**注意：** `{% extends "todolist/base.html"%}`要写在最前面，用来声明要继承的模板位置`{% block 导航栏 %}{% endblock 主题 %}`之间是子页面自己的东西
<br />
**总结：** 模板继承其实就是把子页中的`{% block 导航栏 %}{% endblock 主题 %}`之间的内容放在模板`{% block 导航栏 %}{% endblock 导航栏 %}`之间
## 数据库
Django中默认使用sqlite3，这是一个轻量级数据库，在平常开发中恒少用到，但可以用来练习入门，如果要修改使用的数据库，需要在项目文件夹下的setting.py中如下字段设置
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
```
在设置好数据库后，需要**创建Model类**model类是用来描述表的构成的，诸如列数，表名等等，在app文件夹下的models.py文件中创建Model类，声明表名，列数，列名，类型
```python
from django.db import models

# Create your models here.
class Todo(models.Model):
    thing=models.CharField(max_length=50)
    done=models.BooleanField(default=False)

    def __str__(self):
        return self.thing
```
其中。Todo是表名，thing和done是列名，CharField和BooleanField是列的类型  
虽然Model类声明了表的结构，但Django并不能直接通过Model实现数据库操作，还需要**制作迁移文件**，在命令行中运行
```python
python manage.py makemigrations
```
会自动生成迁移文件
```python
Migrations for 'todolist':
  todolist\migrations\0001_initial.py
    - Create model Todo
```
在迁移文件0001_initial.py中，可以看到我们创建的表的信息
```python
# Generated by Django 2.1.4 on 2019-01-20 05:09

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Todo',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('thing', models.CharField(max_length=50)),
                ('done', models.BooleanField(default=False)),
            ],
        ),
    ]

```
并且发现自动添加了主键id，并且自动递增
**注意：** 每次调整表的结构时必须重新生成迁移文件
迁移文件生成后，就可以在数据库中真的建表了，运行
```python
python manage.py migrate
```
发现运行后建立的不知有Todo一张表
```python
Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying sessions.0001_initial... OK
  Applying todolist.0001_initial... OK
```
原因在于django中有许多自己依赖的数据表，在这之前我们没有使用过，所以没建立，运行上面语句后会被全部建立出来，数据表建立后，就可以进行数据表的增删查改了
可以允许`python manage.py shell`进入Django交互环境进行操作
```python

  
# 引入数据表
>>> from todolist.models import Todo


# 查询所有信息
>>> Todo.objects.all()
<QuerySet []>


# 插入记录
>>> a_row=Todo(thing='看电影',done=False)


# 保存修改
>>> a_row.save()
>>> Todo.objects.all()
<QuerySet [<Todo: 看电影>]>


#查看记录数
>>> Todo.objects.count()
1


# 查看记录信息
>>> a_row.id
2
>>> a_row.thing
'逛街'
>>> a_row.done
True


# 删除记录
>>> a_row.delete()
(1, {'todolist.Todo': 1})
>>> Todo.objects.count()
1


# 查找记录
>>> another_row=Todo.objects.get(id=1)
>>> another_row.thing
'看电影'

# 更新记录
>>> another_row.thing = '去超市' 
>>> another_row.save()

# 退出交互环境
exit()
# 或者 Ctrl+Z Enter
```